generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum BaasProviderName {
  MOCK
  STRIPE_ISSUING
  LITHIC
  UNIT
  OTHER
  SYNCTERA
}

enum AuthHoldStatus {
  PENDING
  CLEARED
  REVERSED
  EXPIRED
}

enum WalletSpendPolicy {
  PAYER_ONLY
  EQUAL_SPLIT
}

enum WithdrawalRequestStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum WithdrawalTransferStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REVERSED
}

enum LedgerScope {
  WALLET_POOL // Legacy: Wallet-level shared pool
  CARD_POOL // Card-level shared pool (primary)
  CARD_MEMBER_EQUITY // Per-member equity tracking per card
  CARD_PENDING_WITHDRAWAL // Pending withdrawal amounts per card
}

model User {
  id             String          @id @default(uuid())
  email          String          @unique
  name           String?
  googleId       String?         @unique
  createdAt      DateTime        @default(now())
  kycStatus      String?
  ledgerAccounts LedgerAccount[]
  walletsAdmin   Wallet[]        @relation("WalletAdmin")
  memberships    WalletMember[]

  baasCustomer       BaasCustomer?
  baasCards          BaasCard[]
  baasFundingRoutes  BaasFundingRoute[]
  cardAuthHolds      CardAuthHold[]
  baasAccounts       BaasAccount[]
  withdrawalRequests WithdrawalRequest[]
}

model Wallet {
  id                         String              @id @default(uuid())
  name                       String
  adminId                    String
  createdAt                  DateTime            @default(now())
  providerFinancialAccountId String?
  spendPolicy                WalletSpendPolicy   @default(PAYER_ONLY)
  cards                      Card[]
  ledgerAccounts             LedgerAccount[]
  admin                      User                @relation("WalletAdmin", fields: [adminId], references: [id])
  walletBalance              WalletBalance?
  members                    WalletMember[]
  baasCards                  BaasCard[]
  baasFundingRoutes          BaasFundingRoute[]
  cardAuthHolds              CardAuthHold[]
  withdrawalRequests         WithdrawalRequest[]
}

model WalletBalance {
  id        String   @id @default(uuid())
  walletId  String   @unique
  amount    Int      @default(0)
  updatedAt DateTime @default(now()) @updatedAt
  wallet    Wallet   @relation(fields: [walletId], references: [id])
}

model WalletMember {
  id       String   @id @default(uuid())
  walletId String
  userId   String
  role     String
  joinedAt DateTime @default(now())
  user     User     @relation(fields: [userId], references: [id])
  wallet   Wallet   @relation(fields: [walletId], references: [id])
}

model Card {
  id             String    @id @default(uuid())
  walletId       String
  providerCardId String?
  status         String    @default("ACTIVE")
  terminatedAt   DateTime?
  archivedAt     DateTime?
  archivedReason String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  wallet         Wallet          @relation(fields: [walletId], references: [id])
  baasAccount    BaasAccount?
  ledgerAccounts LedgerAccount[]
  authHolds      CardAuthHold[]
  archives       CardArchive[]
}

model LedgerAccount {
  id          String       @id @default(uuid())
  walletId    String
  cardId      String? // Card-specific ledger accounts
  userId      String? // For member equity tracking
  type        String // Legacy: "pool", "equity", "pending_withdrawal"
  ledgerScope LedgerScope? // New: CARD_POOL, CARD_MEMBER_EQUITY, etc.
  balance     Int          @default(0)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  user          User?         @relation(fields: [userId], references: [id])
  wallet        Wallet        @relation(fields: [walletId], references: [id])
  card          Card?         @relation(fields: [cardId], references: [id])
  creditEntries LedgerEntry[] @relation("CreditRelation")
  debitEntries  LedgerEntry[] @relation("DebitRelation")

  @@unique([cardId, ledgerScope, userId]) // Unique per card + scope + member
  @@index([walletId, cardId])
}

model LedgerEntry {
  id              String        @id @default(uuid())
  transactionId   String
  debitAccountId  String
  creditAccountId String
  amount          Int
  timestamp       DateTime      @default(now())
  metadata        Json?
  creditAccount   LedgerAccount @relation("CreditRelation", fields: [creditAccountId], references: [id])
  debitAccount    LedgerAccount @relation("DebitRelation", fields: [debitAccountId], references: [id])
}

model BaasCustomer {
  id                 String           @id @default(cuid())
  userId             String           @unique
  providerName       BaasProviderName
  externalCustomerId String           @unique
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  user     User          @relation(fields: [userId], references: [id])
  accounts BaasAccount[]
  cards    BaasCard[]
}

model BaasAccount {
  id                 String           @id @default(cuid())
  userId             String
  cardId             String           @unique // 1:1 with Card - each card owns its account
  baasCustomerId     String?
  providerName       BaasProviderName
  externalAccountId  String           @unique
  accountType        String
  currency           String
  status             String           @default("ACTIVE")
  accessStatus       String?
  accountNumberLast4 String?
  routingNumber      String?
  metadata           Json?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  user          User               @relation(fields: [userId], references: [id])
  card          Card               @relation(fields: [cardId], references: [id])
  baasCustomer  BaasCustomer?      @relation(fields: [baasCustomerId], references: [id])
  baasCards     BaasCard[]
  fundingRoutes BaasFundingRoute[]
}

model BaasCard {
  id             String           @id @default(cuid())
  userId         String
  walletId       String? // optional link to a "default" wallet for this card
  baasCustomerId String?
  baasAccountId  String?
  providerName   BaasProviderName
  externalCardId String           @unique
  last4          String?
  status         String           @default("ACTIVE")
  nickname       String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  user         User          @relation(fields: [userId], references: [id])
  wallet       Wallet?       @relation(fields: [walletId], references: [id])
  baasCustomer BaasCustomer? @relation(fields: [baasCustomerId], references: [id])
  baasAccount  BaasAccount?  @relation(fields: [baasAccountId], references: [id])
}

model BaasEvent {
  id              String           @id @default(cuid())
  providerName    BaasProviderName
  providerEventId String
  type            String // e.g. "CARD_AUTH", "CARD_CLEARING", "WALLET_FUNDING"
  payload         Json
  processedAt     DateTime?
  createdAt       DateTime         @default(now())

  @@unique([providerName, providerEventId])
}

model BaasFundingRoute {
  id                String           @id @default(cuid())
  providerName      BaasProviderName
  providerAccountId String
  reference         String?
  walletId          String
  userId            String
  cardId            String?          // Which card this funding route is for
  baasAccountId     String?
  createdAt         DateTime         @default(now())

  wallet      Wallet       @relation(fields: [walletId], references: [id])
  user        User         @relation(fields: [userId], references: [id])
  baasAccount BaasAccount? @relation(fields: [baasAccountId], references: [id])

  @@unique([providerName, providerAccountId, reference])
  @@index([cardId])
}

model CardAuthHold {
  id             String           @id @default(cuid())
  providerName   BaasProviderName
  providerAuthId String
  providerCardId String
  cardId         String // Link to internal Card model
  walletId       String
  userId         String
  amountMinor    Int
  currency       String
  status         AuthHoldStatus   @default(PENDING)
  metadata       Json?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  clearedAt      DateTime?
  reversedAt     DateTime?

  card   Card   @relation(fields: [cardId], references: [id])
  wallet Wallet @relation(fields: [walletId], references: [id])
  user   User   @relation(fields: [userId], references: [id])

  @@unique([providerName, providerAuthId])
  @@index([cardId, status])
}

model WithdrawalRequest {
  id                  String                  @id @default(cuid())
  walletId            String
  cardId              String // Which card to withdraw from
  userId              String
  amountMinor         Int
  currency            String                  @default("USD")
  status              WithdrawalRequestStatus @default(PENDING)
  ledgerTransactionId String? // Link to ledger transaction
  failureReason       String?
  metadata            Json?
  createdAt           DateTime                @default(now())
  updatedAt           DateTime                @updatedAt
  completedAt         DateTime?
  failedAt            DateTime?

  wallet    Wallet               @relation(fields: [walletId], references: [id])
  user      User                 @relation(fields: [userId], references: [id])
  transfers WithdrawalTransfer[]

  @@index([walletId, status])
  @@index([userId, status])
  @@index([cardId, status])
}

model WithdrawalTransfer {
  id                  String                   @id @default(cuid())
  withdrawalRequestId String
  providerName        BaasProviderName
  providerTransferId  String? // External payout/transfer ID
  amountMinor         Int
  currency            String                   @default("USD")
  status              WithdrawalTransferStatus @default(PENDING)
  failureReason       String?
  metadata            Json?
  createdAt           DateTime                 @default(now())
  updatedAt           DateTime                 @updatedAt
  completedAt         DateTime?
  failedAt            DateTime?

  withdrawalRequest WithdrawalRequest @relation(fields: [withdrawalRequestId], references: [id])

  @@unique([providerName, providerTransferId])
  @@index([withdrawalRequestId])
  @@index([status])
}

model CardArchive {
  id                String   @id @default(cuid())
  cardId            String
  walletId          String
  userId            String // Owner at time of termination
  externalAccountId String? // Synctera account ID
  externalCardId    String? // Synctera card ID
  balanceSnapshot   Json // { poolBalance, memberEquities: [{userId, balance}], pendingWithdrawals }
  terminatedAt      DateTime
  archivedAt        DateTime @default(now())
  reason            String?
  metadata          Json?

  card Card @relation(fields: [cardId], references: [id])

  @@index([cardId])
  @@index([walletId])
  @@index([userId])
}
